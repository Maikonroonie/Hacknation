<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Market Simulator 3D - Professional</title>
    <style>
        body { 
            margin: 0; 
            background-color: #0b0b14; /* Głęboki granat/czerń */
            font-family: 'Segoe UI', sans-serif; 
            overflow: hidden; 
        }
        
        /* Czysty interfejs */
        #ui-layer {
            position: absolute; top: 20px; left: 20px;
            pointer-events: none; z-index: 10;
        }
        
        h1 {
            color: #fff; margin: 0; font-size: 24px; letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        #status {
            color: #4db8ff; font-size: 14px; margin-top: 5px; font-weight: 600;
        }

        /* Elegancka legenda */
        #legend {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            padding: 10px 20px; border-radius: 30px; border: 1px solid #333;
            color: #ccc; font-size: 12px; display: flex; gap: 20px; align-items: center;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .red { background: #ff3333; box-shadow: 0 0 8px #ff3333; }
        .grey { background: #888; }
        .green { background: #00ff00; box-shadow: 0 0 8px #00ff00; }

        /* Logi jako "terminal" */
        #logs {
            position: absolute; top: 100px; left: 20px;
            width: 300px; max-height: 60vh; overflow: hidden;
            font-family: 'Consolas', monospace; font-size: 11px;
            display: flex; flex-direction: column-reverse; /* Nowe na dole */
            mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
        }
        .log-entry { margin-bottom: 4px; color: #667; }
        .log-entry span { color: #fff; }
        .log-entry.imp-pos { border-left: 2px solid #0f0; padding-left: 8px; color: #aea; }
        .log-entry.imp-neg { border-left: 2px solid #f00; padding-left: 8px; color: #eaa; }

    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.8.2/dist/three-spritetext.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
</head>
<body>

<div id="ui-layer">
    <h1>MARKET SIMULATION</h1>
    <div id="status">Inicjalizacja systemu...</div>
</div>

<div id="logs"></div>

<div id="legend">
    <div><span class="dot red"></span>Słaba kondycja (<50)</div>
    <div><span class="dot grey"></span>Równowaga (50)</div>
    <div><span class="dot green"></span>Dobra kondycja (>50)</div>
</div>

<script>
    // ==========================================
    // 1. DANE (HARDCODED)
    // ==========================================
    
    // Lista sąsiedztwa (CSV)
    const CSV_DATA = `
Start,A,50
Start,B,20
A,C,80
A,D,40
B,D,10
C,End,100
D,End,50
End,X,10
`;

    // Słownik wyników (Python print)
    const SCORES_DATA = `
{
  'Start': 100, 
  'A': 50, 
  'B': 50, 
  'C': 50, 
  'D': 50, 
  'End': 50,
  'X': 20
}
`;

    // ==========================================
    // 2. LOGIKA I WIZUALIZACJA
    // ==========================================

    let currentScores = {};
    const Graph = ForceGraph3D();

    // --- Parser CSV ---
    function parseCSV(text) {
        const adj = {};
        text.trim().split(/\r?\n/).forEach(line => {
            if(!line.trim()) return;
            const [s, t, wStr] = line.split(/[;,]/).map(x=>x.trim());
            const w = parseFloat(wStr?.replace('%',''));
            if(s && t && !isNaN(w)) {
                if(!adj[s]) adj[s] = [];
                adj[s].push({ target: t, weight: w });
            }
        });
        return adj;
    }

    // --- Parser Python ---
    function parseScores(text) {
        try {
            let js = text.replace(/\r?\n/g, " ")
                .replace(/\bNone\b/g, 'null').replace(/\bTrue\b/g, 'true').replace(/\bFalse\b/g, 'false');
            return new Function("return " + js)();
        } catch(e) { return {}; }
    }

    // --- Kolory (Interpolacja) ---
    function getNodeColor(val) {
        val = Math.max(0, Math.min(100, val));
        // Czerwony(0) -> Szary(50) -> Zielony(100)
        if(val < 50) return `rgb(255, ${Math.floor(val/50*100)}, ${Math.floor(val/50*100)})`; // Czerwień nasycona
        if(val >= 50) return `rgb(${Math.floor(100 - (val-50)/50*100)}, 255, ${Math.floor(100 - (val-50)/50*100)})`; // Zieleń nasycona
    }

    // --- Logger ---
    function log(html, type='') {
        const c = document.getElementById('logs');
        const d = document.createElement('div');
        d.className = `log-entry ${type}`;
        d.innerHTML = html;
        c.prepend(d); // Nowe na górze (technicznie na dole przez flex-reverse)
        if(c.children.length > 10) c.lastChild.remove();
    }

    // --- Renderowanie Kuli 3D ---
    function createNodeObject(node) {
        const group = new THREE.Group();

        // 1. Kula (Sfera)
        const geometry = new THREE.SphereGeometry(6, 32, 32);
        const material = new THREE.MeshPhongMaterial({ 
            color: node.color, 
            shininess: 50,
            emissive: node.color,
            emissiveIntensity: 0.3
        });
        const sphere = new THREE.Mesh(geometry, material);
        group.add(sphere);

        // 2. Tekst nad kulą
        const sprite = new SpriteText(node.id);
        sprite.color = '#ffffff';
        sprite.textHeight = 4;
        sprite.position.y = 10; // Przesunięcie nad kulę
        group.add(sprite);

        return group;
    }

    async function init() {
        const adj = parseCSV(CSV_DATA);
        const scores = parseScores(SCORES_DATA);
        currentScores = {...scores};

        // Budowa danych grafu
        const nodes = new Set();
        const links = [];
        
        Object.keys(adj).forEach(src => {
            nodes.add(src);
            adj[src].forEach(e => {
                nodes.add(e.target);
                links.push({ source: src, target: e.target, weight: e.weight });
            });
        });
        Object.keys(scores).forEach(k => nodes.add(k));

        const gData = {
            nodes: Array.from(nodes).map(id => ({ id, val: currentScores[id]||50 })),
            links: links
        };

        // Inicjalizacja Sceny
        Graph(document.body)
            .graphData(gData)
            .backgroundColor('#0b0b14')
            .showNavInfo(false)
            .nodeColor(n => getNodeColor(currentScores[n.id]||50))
            
            // Wygląd węzłów (Kule 3D)
            .nodeThreeObject(createNodeObject)
            
            // Wygląd Krawędzi
            .linkWidth(1)
            .linkColor(() => '#333344') // Ciemne, subtelne linie
            .linkDirectionalArrowLength(3.5)
            .linkDirectionalArrowRelPos(1)
            .linkThreeObjectExtend(true)
            .linkThreeObject(link => {
                // Waga jako mały tekst na linii
                const sprite = new SpriteText(`${link.weight}%`);
                sprite.color = '#556'; sprite.textHeight = 1.5;
                return sprite;
            })
            .linkPositionUpdate((sprite, { start, end }) => {
                Object.assign(sprite.position, {
                    x: start.x + (end.x - start.x)/2,
                    y: start.y + (end.y - start.y)/2,
                    z: start.z + (end.z - start.z)/2
                });
            });

        // Oświetlenie sceny (żeby kule były 3D)
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(100, 100, 100);
        Graph.scene().add(light);
        Graph.scene().add(new THREE.AmbientLight(0xbbbbbb));

        // Stabilizacja grafu (warmup)
        document.getElementById('status').innerText = "Stabilizowanie grafu...";
        Graph.d3Force('charge').strength(-200); // Mniejsze odpychanie
        
        // Czekamy chwilę przed startem symulacji
        await new Promise(r => setTimeout(r, 2000));
        
        runBFS(adj);
    }

    // --- SYMULACJA BFS ---
    async function runBFS(adj) {
        document.getElementById('status').innerText = "SYMULACJA AKTYWNA";
        
        let queue = [];
        let visitedCounts = {};
        const THRESHOLD = 0.1;

        // Inicjalizacja kolejki
        Object.keys(currentScores).forEach(id => {
            if(Math.abs((currentScores[id]||50) - 50) > THRESHOLD) queue.push(id);
        });

        while(queue.length > 0) {
            const u = queue.shift();
            
            // Zabezpieczenie pętli
            if((visitedCounts[u]||0) > 100) continue;
            visitedCounts[u] = (visitedCounts[u]||0) + 1;

            const force = (currentScores[u]||50) - 50;
            if(Math.abs(force) < THRESHOLD) continue;

            const neighbors = adj[u] || [];
            
            for(let edge of neighbors) {
                const v = edge.target;
                const weight = edge.weight;

                // Animacja cząsteczki (Impuls)
                const link = Graph.graphData().links.find(l => l.source.id === u && l.target.id === v);
                if(link) {
                    Graph.emitParticle(link);
                    Graph.linkDirectionalParticleColor(() => force > 0 ? '#00ff44' : '#ff4444'); // Neon Green/Red
                    Graph.linkDirectionalParticleWidth(4);
                    Graph.linkDirectionalParticleSpeed(0.01);
                }

                // Czas przelotu
                await new Promise(r => setTimeout(r, 600));

                // Matematyka
                const impact = force * (weight / 100.0);
                const oldVal = currentScores[v] || 50;
                let newVal = Math.max(0, Math.min(100, oldVal + impact));

                if(Math.abs(newVal - oldVal) > THRESHOLD) {
                    const diff = newVal - oldVal;
                    currentScores[v] = newVal;
                    queue.push(v);

                    // Logowanie
                    const arrow = diff > 0 ? '↑' : '↓';
                    const type = diff > 0 ? 'imp-pos' : 'imp-neg';
                    log(`${u} → ${v} <span>${arrow} ${Math.abs(diff).toFixed(1)}</span>`, type);

                    // Aktualizacja koloru węzła
                    // Musimy zaktualizować obiekt Three.js
                    const nodeObj = Graph.graphData().nodes.find(n => n.id === v);
                    if(nodeObj && nodeObj.__threeObj) {
                        // Szukamy Mesh w Grupie
                        const mesh = nodeObj.__threeObj.children.find(c => c.type === 'Mesh');
                        if(mesh) {
                            const newColor = new THREE.Color(getNodeColor(newVal));
                            mesh.material.color.set(newColor);
                            mesh.material.emissive.set(newColor);
                        }
                    }
                }
            }
        }
        document.getElementById('status').innerText = "SYMULACJA ZAKOŃCZONA";
        document.getElementById('status').style.color = "#888";
    }

    // Start
    init();

</script>
</body>
</html>