from manim import *
import networkx as nx

# --- 1. DANE Z TWOJEJ SYMULACJI (MOCK) ---
# W prawdziwym projekcie zaimportowałbyś tu wynik funkcji run_market_simulation_bfs
# Tutaj wpisuję przykładowe dane, żeby kod był uruchamialny "od ręki"

# Graf zależności (Kto -> Komu, Waga)
EDGES = [
    ("35", "10", 0.2), # Energetyka -> Spożywka
    ("35", "41", 0.3), # Energetyka -> Budowlanka
    ("10", "55", 0.4), # Spożywka -> Hotele (Hotele kupują jedzenie)
    ("41", "68", 0.5), # Budowlanka -> Nieruchomości
    ("01", "10", 0.8), # Rolnictwo -> Spożywka
]

# Historia z BFS (Kto kogo zaraził i w jakiej kolejności)
# Format: (Źródło, Cel, Nowy_Score)
BFS_HISTORY = [
    ("35", "10", 80), # Krok 1: Energetyka uderza w Spożywkę
    ("35", "41", 70), # Krok 1: Energetyka uderza w Budowlankę
    ("10", "55", 85), # Krok 2: Osłabiona Spożywka uderza w Hotele
    ("41", "68", 60), # Krok 2: Osłabiona Budowlanka uderza w Nieruchomości
]

class MarketContagionScene(Scene):
    def construct(self):
        # --- 2. KONFIGURACJA GRAFU ---
        
        # Tworzymy listę wierzchołków i krawędzi
        vertices = list(set([e[0] for e in EDGES] + [e[1] for e in EDGES]))
        edges = [(e[0], e[1]) for e in EDGES]
        
        # Układ grafu (Layout) - używamy spring_layout z NetworkX dla ładnego rozłożenia
        nx_graph = nx.DiGraph()
        nx_graph.add_edges_from(edges)
        layout = nx.spring_layout(nx_graph, seed=42) # Stały seed żeby graf nie skakał
        
        # Konwersja layoutu do formatu Manim (skalowanie do ekranu)
        manim_layout = {k: [v[0]*3, v[1]*3, 0] for k, v in layout.items()}

        # Tworzenie obiektu Graph w Manim
        g = Graph(
            vertices,
            edges,
            layout=manim_layout,
            vertex_config={"radius": 0.4, "color": GREEN},
            edge_config={"stroke_width": 2, "color": GRAY},
            labels=True # Pokazuj kody PKD
        )

        # --- 3. ANIMACJA: WSTĘP ---
        
        title = Text("Symulacja Zakażenia Rynku (Efekt Domina)", font_size=36).to_edge(UP)
        self.play(Write(title))
        self.play(Create(g), run_time=2)
        self.wait(1)

        # --- 4. ANIMACJA: ŹRÓDŁO KRYZYSU ---
        
        source_node = "35" # Energetyka
        self.play(
            g[source_node].animate.scale(1.5).set_color(RED),
            Flash(g[source_node], color=RED, flash_radius=0.6),
            run_time=1
        )
        self.wait(0.5)

        # --- 5. ANIMACJA: ROZCHODZENIE SIĘ FALI (Pętla po historii BFS) ---
        
        for source, target, new_score in BFS_HISTORY:
            # 1. Podświetl krawędź, którą płynie "zakażenie"
            edge = (source, target)
            self.play(
                g.edges[edge].animate.set_color(ORANGE).set_stroke_width(6),
                run_time=0.5
            )
            self.play(
                g.edges[edge].animate.set_color(GRAY).set_stroke_width(2),
                run_time=0.3
            )

            # 2. Oblicz kolor na podstawie wyniku (Interpolacja Żółty -> Czerwony)
            # Im niższy wynik, tym bardziej czerwony
            severity = (100 - new_score) / 100.0 # Np. 0.2
            new_color = interpolate_color(YELLOW, RED, severity)
            new_scale = 1.0 + severity # Węzeł rośnie wraz z problemami

            # 3. Zmień stan węzła docelowego
            self.play(
                g[target].animate.set_color(new_color).scale(new_scale),
                run_time=0.8
            )
            
            # (Opcjonalnie) Dodaj tekst z wynikiem
            score_label = Text(f"{new_score}", font_size=20, color=WHITE).next_to(g[target], DOWN)
            self.add(score_label)
            self.wait(0.2)
            self.remove(score_label) # Czyścimy, żeby nie zaśmiecać

        # --- 6. FINAŁ ---
        self.wait(2)
        final_text = Text("Koniec symulacji", font_size=24).to_edge(DOWN)
        self.play(FadeIn(final_text))
        self.wait(2)